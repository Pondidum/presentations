<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8"/>

    <title>Tech Talk - Event Sourcing</title>

    <meta name="description" content="What is Event Sourcing, and why should I use it"/>
    <meta name="author" content="Andy Davies"/>

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <link rel="stylesheet" href="css/reveal.min.css"/>
    <link rel="stylesheet" href="css/theme/blood.css" id="theme"/>

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css"/>
    <link rel="stylesheet" href="lib/css/tweaks.css" />

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

  </head>

  <body>

    <div class="reveal">

      <div class="slides">

        <section class="title-slide">
          <h3>Tech Talk<br/>Event Sourcing</h3>
          <img src="m/avatar.png" />
          <p class="small centre">@andydote</p>
        </section>

        <section>
          <img src="m/jackie-chan-meme.jpg" />
          <div class="pic-label big">
            What is it?
          </div>
          <aside class="notes">
            <ul>
              <li>It is a different way of storing data</li>
              <li>Slightly more complex than relational to implement</li>
              <li>But infinitely more powerful</li>
              <li>It provides history, which is immutable</li>
              <li>event sourcing can be transformed to any other store type</li>
            </ul>
          </aside>
        </section>

        <section>
          <pre><code>
  {
    PlacedOn: new Date(2014, 4, 14),
    State: States.Completed,
    Items: [
      {
        Name: "The Raid",
        Price: 12.99,
        Quantity: 1
      },
      {
        Name: "Dispicable Me",
        Price: 14.99,
        Quantity: 1
      }
    ],
  }
          </code></pre>
          <aside class="notes">
            <ul>
              <li>This tells us that an order was completed, and had these two items in it.</li>
              <li>We can't tell what the user did before, or how they arrived at this order.</li>
              <li>Probably represented as Basket, OrderLine, Product tables</li>
              <li>So, what is the history of that basket?</li>
            </ul>
          </aside>
        </section>

        <section>
          <img class="image-stack" src="m/event-stream-1.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-2.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-3.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-4.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-5.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-6.png" /><br />
          <img class="image-stack fragment" src="m/event-stream-7.png" />
          <aside class="notes">
            <ul>
              <li>allows business to ask questions of what happened in the past</li>
              <li>eg: do we get many people who add items to their basket, remove it then buy it within a week?</li>
              <li>also acts as an audit trail for free!</li>
              <li>No table structure changes ever needed, so simpler handling ot upgrades</li>
              <li>perf concerns?</li>
            </ul>
          </aside>
        </section>

        <section>
          <section>
            <pre><code class="sql">
  create table events (
    id serial primary key, aggregateID integer, sequence integer, eventData json
  )


  select *
  from events
  where aggregateID = @aggregateID
  order by sequence asc


  insert into events(aggregateID, sequence, eventData)
  values (1234, 1, '{ "name":"test" }')
            </code></pre>
            <aside class="notes">
              <ul>
                <li>We only need one table for all of our data (or maybe one per aggregate root)</li>
                <li>and one select, and one insert</li>
                <li>NO UPDATE.</li>
                <li>Performance: snapshot every x events</li>
              </ul>
            </aside>
          </section>
          <section>
            <pre><code class="sql">
  select aggregateID, eventSequence, snapshotData
  from snapshots
  where aggregateID = @aggregateID
  order by sequence asc
  limit 1

  select e.aggregateID, e.eventID, e.eventData
  from events e
  join snapshots s on e.aggregateID = s.aggregateID
  where e.aggregateID = @aggregateID
    and e.sequence &gt; s.eventSequence
  order by e.sequence asc
            </code></pre>
          </section>
          <section>
            <pre><code class="sql">
  select count(*)
  from dev.events
  where eventData -&gt;&gt; 'type' = @eventType
    and eventData -&gt; 'data' -&gt;&gt; 'name' = @productName

  select count(*), eventData -&gt; 'data' -&gt;&gt; 'name'
  from dev.events
  where eventData -&gt;&gt; 'type' = 'productAdded'
  group by eventData -&gt; 'data' -&gt;&gt; 'name'
            </code></pre>
            <aside class="notes">
              <ul>
                <li>You can do adhock queries if needed</li>
                <li>but only on events, not current state</li>
                <li>We can solve this with a readmodel/data warehouse</li>
              </ul>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <pre><code class="c#">
  public class Basket {

    public IEnumerable&lt;BasketEntry&gt; Items { get { return _items; }}

    private readonly List&lt;BasketEntry&gt; _items = new List&lt;BasketEntry&gt;();

    public void AddToBasket(Item item) {

      var entry = _items.FirstOrDefault(entry =&gt; entry.Item == item);

      if (entry == null) {
        entry = new BasketEntry(item);
        _items.Add(entry);
      }

      entry.Quantity++;
    }
  }
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Exibits Rich Domain Modeling</li>
                <li>Small amount of logic to add an item to the basket</li>
                <li>can be converted fairly easily</li>
              </ul>
            </aside>
          </section>
          <section>
            <pre><code class="c#">
  public class Basket : AggregateRoot {

    public IEnumerable&lt;BasketEntry&gt; Items { get { return _items; }}

    private readonly List&lt;BasketEntry&gt; _items = new List&lt;BasketEntry&gt;();

    public void AddToBasket(Item item) {
      Apply(new AddToBasketEvent(item));
    }

    private void Handle(ApplyToBasketEvent e) {
      var entry = _items.FirstOrDefault(entry =&gt; entry.Item == e.Item);

      if (entry == null) {
        entry = new BasketEntry(e.Item);
        _items.Add(entry);
      }

      entry.Quantity++;
    }
  }
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Inherit from aggregate root</li>
                <li>move the method implementation to a Handle() method</li>
                <li>A domain event is just a poco (real impl include sequence numbers etc)</li>
              </ul>
            </aside>
          </section>
          <section>
            <pre><code class="c#">
  public class AggregateRoot : IEventStream {

    private readonly List&lt;DomainEvent&gt; _uncommittedEvents;

    protected void Apply(DomainEvent e) {
      _uncommittedEvents.Add(e);
      this.AsDynamic().Handle(e);
    }

    IEnumerable&lt;DomainEvent&gt; IEventStream.UncommittedEvents {
      return _uncommittedEvents;
    }

    void IEventStream.ClearEvents {
      _uncommittedEvents.Clear();
    }

    void IEventStream.LoadFromStream(IEnumerable&lt;DomainEvent&gt; stream) {
      var dynamic = this.AsDynamic();
      stream.ForEach(e =&gt; dynamic.Handle(e));
    }
  }
            </code></pre>
            <aside class="notes">
              <ul>
                <li>Every event applied gets stored in a collection</li>
                <li>private IEventStream implementation for storage</li>
                <li>Storage just gets all uncommitted changes, saves them and clears them</li>
                <li>Loading calls the handle method for each event, but doesnt add to uncommmitted</li>
              </ul>
            </aside>
          </section>
        </section>


        <section>
          <img src="m/cat-questions.jpg"/>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script type="text/javascript">

      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        width: 1920,
        height: 1080,

        margin:0.1,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'zoom', // default/cube/page/concave/zoom/linear/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
        ]
      });

    </script>

  </body>
</html>
